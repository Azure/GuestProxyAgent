// Copyright (c) Microsoft Corporation
// SPDX-License-Identifier: MIT

use crate::misc_helpers;

pub mod logger_manager;
pub mod rolling_logger;

pub type LoggerLevel = log::Level;

const HEADER_LENGTH: usize = 34;
pub fn get_log_header(level: LoggerLevel) -> String {
    get_log_header_with_length(
        level,
        misc_helpers::get_date_time_string_with_milliseconds(),
        HEADER_LENGTH,
    )
}

fn get_log_header_with_length(
    level: LoggerLevel,
    date_time_string: String,
    length: usize,
) -> String {
    let header = format!("{date_time_string} [{level}]    ")
        .chars()
        .take(length)
        .collect::<String>();

    // padding if the header is shorter than HEADER_LENGTH
    if header.len() < length {
        let padding = " ".repeat(length - header.len());
        return format!("{header}{padding}");
    }
    header
}

const ASYNC_FUNCTION_NAME: &str = "{closure";
const INTERNAL_BACKTRACE: &str = "backtrace";
const CURRENT_FUNCTION: &str = "::logger::get_caller_info";
const RUNTIME_TASK_SCHEDULER: &str = "::runtime::task::Schedule"; // The runtime scheduler function that runs the tasks

#[cfg(test)]
const TEST_CODE_COVERAGE_FUNCTIONS: &str = "__covrec_"; // code coverage recording, generated by a code coverage tool such as llvm-cov, or a similar instrumentation framework
#[cfg(test)]
const TEST_INTERNAL_FUNCTION: &str = "test::run_test"; // The test framework's internal function that runs the tests

pub fn get_caller_info(module_to_skip: &str) -> (String, String) {
    let bt = backtrace::Backtrace::new();
    for frame in bt.frames().iter() {
        for symbol in frame.symbols() {
            if let Some(name) = symbol.name() {
                let name_str = name.to_string();

                let mut found_function: bool = true;
                // Skip internal frames, current function frame and `module_to_skip` to find the first relevant caller
                found_function = found_function
                    && !name_str.contains(INTERNAL_BACKTRACE)
                    && !name_str.contains(CURRENT_FUNCTION)
                    && !name_str.contains(RUNTIME_TASK_SCHEDULER)
                    && !name_str.contains(module_to_skip);

                #[cfg(test)]
                {
                    found_function = found_function
                        && !name_str.contains(TEST_CODE_COVERAGE_FUNCTIONS)
                        && !name_str.starts_with(TEST_INTERNAL_FUNCTION);
                }

                if found_function {
                    // If the name contains `{{closure}}`, it indicates an async function
                    // We need to find the first segment that contains the async function name
                    // Example: `azure_proxy_agent::proxy::proxy_server::ProxyServer::handle_new_tcp_connection::{{closure}}::{{closure}}::h537d19fb7a504d22`
                    let seg = name_str.split("::").collect::<Vec<_>>();
                    let seg_len = seg.len();
                    let mut function_last_index = 0;
                    for i in 0..seg_len {
                        if seg[seg_len - 1 - i].contains(ASYNC_FUNCTION_NAME) {
                            function_last_index = i + 1;
                        }
                    }
                    let caller_name = seg
                        .get(seg_len - 1 - function_last_index)
                        .unwrap_or(&"unknown")
                        .to_string();
                    // Get the module name from the first to `function_last_index` segment
                    let module_name = seg
                        .into_iter()
                        .map(String::from)
                        .collect::<Vec<_>>()
                        .into_iter()
                        .take(seg_len - 1 - function_last_index)
                        .collect::<Vec<_>>()
                        .join("::");
                    return (module_name, caller_name);
                }
            }
        }
    }
    ("unknown".to_string(), "unknown".to_string())
}

#[cfg(test)]
mod tests {
    use log::Level;
    use std::str::FromStr;

    #[test]
    fn logger_level_test() {
        let info_level = Level::Info;
        assert_eq!(Level::from_str("Info").unwrap(), Level::Info);

        let trace_level = Level::from_str("Trace").unwrap();
        assert_eq!(trace_level, Level::Trace);
        assert!(
            info_level < trace_level,
            "Info level should be lower than Trace level"
        );

        assert!(
            Level::from_str("Trace").unwrap() >= trace_level,
            "Trace level should be greater than or equal to Trace level"
        );
    }

    #[tokio::test]
    async fn invoke_get_caller_info_test() {
        test_get_caller_info_test("invoke_get_caller_info_test");
    }

    fn test_get_caller_info_test(expected_caller_name: &str) {
        let (module_name, caller_name) = super::get_caller_info("test_get_caller_info_test");
        println!("Module Name: {}", module_name);
        println!("Caller Name: {}", caller_name);
        // Check if the caller name is as expected
        assert_eq!(caller_name, expected_caller_name);
    }

    #[test]
    fn get_log_header_with_length_test() {
        let header = super::get_log_header_with_length(
            Level::Info,
            "2023-10-01 12:00:00.000".to_string(),
            34,
        );
        assert_eq!(header, "2023-10-01 12:00:00.000 [INFO]    ");
        let header = super::get_log_header_with_length(
            Level::Error,
            "2023-10-01 12:00:00.000".to_string(),
            34,
        );
        assert_eq!(header, "2023-10-01 12:00:00.000 [ERROR]   ");
        let header = super::get_log_header_with_length(
            Level::Warn,
            "2023-10-01 12:00:00.00".to_string(),
            34,
        );
        assert_eq!(header, "2023-10-01 12:00:00.00 [WARN]     ");
    }
}
